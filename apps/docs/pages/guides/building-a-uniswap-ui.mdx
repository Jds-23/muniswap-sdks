# Building a Uniswap V4 UI

This guide walks you through building a complete Uniswap V4 liquidity management interface from scratch. The guide is divided into six phases, each building on the previous one.

## Overview

By the end of this guide, you'll have a fully functional UI with:

- Wallet connection via RainbowKit
- Token selection and balance display
- Pool configuration (fee tiers, tick spacing, hooks)
- Position management (mint, view liquidity)
- Swap functionality with quotes
- Multi-step approval flows (ERC20 + Permit2)
- Transaction status tracking

## Prerequisites

- Node.js >= 20
- pnpm >= 9 (recommended) or npm/yarn
- Basic knowledge of React, TypeScript, and Ethereum
- A WalletConnect Project ID (get one at [cloud.walletconnect.com](https://cloud.walletconnect.com))

---

## Phase 1: Project Setup

This phase establishes the foundational project structure with Vite, TypeScript, and code quality tools.

### 1.1 Initialize the Project

```bash
# Create a new Vite project with React and TypeScript
pnpm create vite my-uniswap-ui --template react-ts
cd my-uniswap-ui

# Install dependencies
pnpm install
```

### 1.2 Configure TypeScript

Create a strict TypeScript configuration optimized for Web3 development.

```json title="tsconfig.json"
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
```

**Key settings:**
- `target: ES2020` - Enables native BigInt support (critical for blockchain math)
- `strict: true` - Catches type errors early
- `noUncheckedIndexedAccess: true` - Forces null checks on array/object access
- `paths` - Enables clean imports like `@/components/...`

### 1.3 Configure Vite

```typescript title="vite.config.ts"
import path from "node:path";
import react from "@vitejs/plugin-react";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
```

### 1.4 Set Up Biome (Linting & Formatting)

Install and configure Biome for consistent code style.

```bash
pnpm add -D @biomejs/biome
```

```json title="biome.json"
{
  "$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
  "organizeImports": {
    "enabled": true
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "space",
    "indentWidth": 2
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double",
      "semicolons": "always"
    }
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "correctness": {
        "noUnusedImports": "error",
        "useExhaustiveDependencies": "warn"
      },
      "style": {
        "noNonNullAssertion": "off"
      }
    }
  }
}
```

Add scripts to `package.json`:

```json title="package.json"
{
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "lint": "biome check .",
    "lint:fix": "biome check --write .",
    "format": "biome format --write ."
  }
}
```

### 1.5 Project Structure

Create the initial directory structure:

```bash
mkdir -p src/{components,hooks,config,constants,types,lib,abi,providers,pages}
mkdir -p src/components/{ui,layout,token,pool,position,swap,wallet,approval,transaction}
mkdir -p src/hooks/{approval,pool,position,swap,token,transaction}
```

**Directory purposes:**
- `components/` - React components organized by domain
- `hooks/` - Custom React hooks for data fetching and logic
- `config/` - Application configuration (chains, wagmi)
- `constants/` - Static values (addresses, defaults, tokens)
- `types/` - TypeScript interfaces and types
- `lib/` - Utility functions
- `abi/` - Contract ABIs
- `providers/` - React context providers
- `pages/` - Page-level components

---

## Phase 2: UI Foundation

This phase sets up the visual layer with Tailwind CSS and shadcn/ui components.

### 2.1 Install Tailwind CSS

```bash
pnpm add -D tailwindcss postcss autoprefixer
pnpm add tailwindcss-animate class-variance-authority clsx tailwind-merge
npx tailwindcss init -p
```

```typescript title="tailwind.config.ts"
import type { Config } from "tailwindcss";
import tailwindcssAnimate from "tailwindcss-animate";

export default {
  darkMode: ["class"],
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [tailwindcssAnimate],
} satisfies Config;
```

### 2.2 Global Styles with CSS Variables

```css title="src/index.css"
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
```

### 2.3 Utility Function for Class Names

```typescript title="src/lib/utils.ts"
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

### 2.4 Install shadcn/ui Base Components

```bash
# Install Radix UI primitives
pnpm add @radix-ui/react-dialog @radix-ui/react-label @radix-ui/react-select \
         @radix-ui/react-slot @radix-ui/react-switch @radix-ui/react-tabs

# Install icon library
pnpm add lucide-react
```

Create shadcn/ui configuration:

```json title="components.json"
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}
```

### 2.5 Create Base UI Components

Create reusable UI primitives. Here's an example Button component:

```typescript title="src/components/ui/Button.tsx"
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = "Button";

export { Button, buttonVariants };
```

Similarly, create Card, Input, Label, Select, Dialog, Switch, and Tabs components following the [shadcn/ui documentation](https://ui.shadcn.com/docs/components).

---

## Phase 3: Web3 Integration

This phase connects your UI to Ethereum using wagmi, viem, and RainbowKit.

### 3.1 Install Web3 Dependencies

```bash
pnpm add viem wagmi @rainbow-me/rainbowkit @tanstack/react-query @tanstack/react-router
```

### 3.2 Define Supported Chains

```typescript title="src/config/chains.ts"
import { arbitrum, base, mainnet, optimism } from "wagmi/chains";

export const supportedChains = [arbitrum, base, mainnet, optimism] as const;

export type SupportedChainId = (typeof supportedChains)[number]["id"];
```

### 3.3 Configure Wagmi

```typescript title="src/config/wagmi.ts"
import { getDefaultConfig } from "@rainbow-me/rainbowkit";
import { arbitrum, base, mainnet, optimism } from "wagmi/chains";

const projectId = import.meta.env.VITE_WALLETCONNECT_PROJECT_ID || "demo";

export const wagmiConfig = getDefaultConfig({
  appName: "Uniswap V4 UI",
  projectId,
  chains: [arbitrum, base, mainnet, optimism],
  ssr: false,
});
```

Create environment file:

```bash title=".env"
VITE_WALLETCONNECT_PROJECT_ID=your_project_id_here
```

### 3.4 Set Up Providers

```typescript title="src/providers/index.tsx"
import { RainbowKitProvider, darkTheme } from "@rainbow-me/rainbowkit";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { WagmiProvider } from "wagmi";
import { wagmiConfig } from "@/config/wagmi";

import "@rainbow-me/rainbowkit/styles.css";

const queryClient = new QueryClient();

interface ProvidersProps {
  children: React.ReactNode;
}

export function Providers({ children }: ProvidersProps) {
  return (
    <WagmiProvider config={wagmiConfig}>
      <QueryClientProvider client={queryClient}>
        <RainbowKitProvider theme={darkTheme()}>
          {children}
        </RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

### 3.5 Create Wallet Connect Button

```typescript title="src/components/wallet/ConnectButton.tsx"
import { ConnectButton as RainbowConnectButton } from "@rainbow-me/rainbowkit";

export function ConnectButton() {
  return <RainbowConnectButton />;
}
```

### 3.6 Define Contract ABIs

```typescript title="src/abi/erc20.ts"
export const erc20Abi = [
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [{ name: "account", type: "address" }],
    outputs: [{ name: "", type: "uint256" }],
  },
  {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" },
    ],
    outputs: [{ name: "", type: "uint256" }],
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" },
    ],
    outputs: [{ name: "", type: "bool" }],
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [{ name: "", type: "uint8" }],
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [{ name: "", type: "string" }],
  },
] as const;
```

### 3.7 Contract Addresses by Chain

```typescript title="src/constants/addresses.ts"
import type { Address } from "viem";
import { arbitrum, base, mainnet, optimism } from "wagmi/chains";

type ChainAddresses = {
  POOL_MANAGER: Address;
  POSITION_MANAGER: Address;
  STATE_VIEW: Address;
  PERMIT2: Address;
  UNIVERSAL_ROUTER: Address;
};

export const ADDRESSES: Record<number, ChainAddresses> = {
  [mainnet.id]: {
    POOL_MANAGER: "0x...",      // Replace with actual addresses
    POSITION_MANAGER: "0x...",
    STATE_VIEW: "0x...",
    PERMIT2: "0x000000000022D473030F116dDEE9F6B43aC78BA3",
    UNIVERSAL_ROUTER: "0x...",
  },
  [arbitrum.id]: {
    POOL_MANAGER: "0x...",
    POSITION_MANAGER: "0x...",
    STATE_VIEW: "0x...",
    PERMIT2: "0x000000000022D473030F116dDEE9F6B43aC78BA3",
    UNIVERSAL_ROUTER: "0x...",
  },
  // Add other chains...
};

export function getAddress(chainId: number, contract: keyof ChainAddresses): Address {
  const addresses = ADDRESSES[chainId];
  if (!addresses) throw new Error(`Unsupported chain: ${chainId}`);
  return addresses[contract];
}
```

### 3.8 Create Token Balance Hook

```typescript title="src/hooks/token/useTokenBalance.ts"
import type { Address } from "viem";
import { useAccount, useChainId, useReadContract } from "wagmi";
import { erc20Abi } from "@/abi/erc20";

interface UseTokenBalanceResult {
  balance: bigint | undefined;
  isLoading: boolean;
  error: Error | null;
  refetch: () => void;
}

export function useTokenBalance(tokenAddress?: Address): UseTokenBalanceResult {
  const { address: userAddress } = useAccount();
  const chainId = useChainId();

  const { data, isLoading, error, refetch } = useReadContract({
    address: tokenAddress,
    abi: erc20Abi,
    functionName: "balanceOf",
    args: userAddress ? [userAddress] : undefined,
    chainId,
    query: {
      enabled: !!tokenAddress && !!userAddress,
    },
  });

  return {
    balance: data,
    isLoading,
    error: error as Error | null,
    refetch,
  };
}
```

---

## Phase 4: SDK Integration

This phase integrates the Uniswap SDK packages for pool and position calculations.

### 4.1 Install SDK Packages

```bash
pnpm add @muniswap/sdk-core @muniswap/v4-sdk
```

Or if working within the monorepo, use workspace references:

```json title="package.json"
{
  "dependencies": {
    "@muniswap/sdk-core": "workspace:*",
    "@muniswap/v4-sdk": "workspace:*"
  }
}
```

### 4.2 Define Types

```typescript title="src/types/pool.ts"
import type { Address } from "viem";

export interface PoolKey {
  currency0: Address;
  currency1: Address;
  fee: number;
  tickSpacing: number;
  hooks: Address;
}

export interface PoolState {
  poolId: Address;
  sqrtPriceX96: bigint;
  tick: number;
  protocolFee: number;
  lpFee: number;
  liquidity: bigint;
}

export interface PoolConfig {
  token0: Address;
  token1: Address;
  fee: number;
  tickSpacing: number;
  hooks: Address;
}
```

```typescript title="src/types/position.ts"
export interface PositionConfig {
  tickLower: number;
  tickUpper: number;
  amount0: string;
  amount1: string;
}

export interface PositionPreview {
  liquidity: bigint;
  amount0: bigint;
  amount1: bigint;
  amount0Max: bigint;
  amount1Max: bigint;
}

export type ApprovalStep =
  | "token0_to_permit2"
  | "token1_to_permit2"
  | "permit2_token0"
  | "permit2_token1"
  | "ready";
```

### 4.3 Pool Constants

```typescript title="src/constants/defaults.ts"
export const DEFAULT_POOL = {
  fee: 3000,           // 0.3%
  tickSpacing: 60,
  hooks: "0x0000000000000000000000000000000000000000" as const,
};

export const FEE_TIERS = [
  { fee: 100, tickSpacing: 1, label: "0.01%" },
  { fee: 500, tickSpacing: 10, label: "0.05%" },
  { fee: 3000, tickSpacing: 60, label: "0.3%" },
  { fee: 10000, tickSpacing: 200, label: "1%" },
] as const;

export const TICK_RANGE_FULL = {
  tickLower: -887220,
  tickUpper: 887220,
};

export const DEFAULT_SLIPPAGE_TOLERANCE = 100; // 1% in bps
export const DEFAULT_DEADLINE_MINUTES = 20;

export const MAX_UINT160 = 2n ** 160n - 1n;
export const MAX_UINT256 = 2n ** 256n - 1n;
```

### 4.4 Create Pool State Hook

```typescript title="src/hooks/pool/usePoolState.ts"
import { useMemo } from "react";
import type { Address } from "viem";
import { useChainId, useReadContract } from "wagmi";
import { stateViewAbi } from "@/abi/stateView";
import { getAddress } from "@/constants/addresses";
import type { PoolKey, PoolState } from "@/types/pool";

export function usePoolState(poolKey: PoolKey | undefined) {
  const chainId = useChainId();
  const stateView = getAddress(chainId, "STATE_VIEW");

  // Compute pool ID from pool key
  const poolId = useMemo(() => {
    if (!poolKey) return undefined;
    // Pool ID is keccak256 of encoded pool key
    // Implementation depends on SDK
    return undefined; // Replace with actual computation
  }, [poolKey]);

  const { data, isLoading, error } = useReadContract({
    address: stateView,
    abi: stateViewAbi,
    functionName: "getSlot0",
    args: poolId ? [poolId] : undefined,
    chainId,
    query: {
      enabled: !!poolId,
    },
  });

  const poolState: PoolState | undefined = useMemo(() => {
    if (!data || !poolId) return undefined;
    const [sqrtPriceX96, tick, protocolFee, lpFee] = data;
    return {
      poolId,
      sqrtPriceX96,
      tick,
      protocolFee,
      lpFee,
      liquidity: 0n, // Fetch separately if needed
    };
  }, [data, poolId]);

  return { poolState, isLoading, error };
}
```

### 4.5 Create Position Hook

```typescript title="src/hooks/position/usePosition.ts"
import { useMemo } from "react";
import { Pool, Position } from "@muniswap/v4-sdk";
import { Token } from "@muniswap/sdk-core";
import type { Address } from "viem";

interface UsePositionParams {
  chainId: number;
  token0: { address: Address; decimals: number };
  token1: { address: Address; decimals: number };
  fee: number;
  tickSpacing: number;
  hooks: Address;
  sqrtPriceX96: bigint;
  liquidity: bigint;
  tick: number;
  tickLower: number;
  tickUpper: number;
  amount0: string;
  amount1: string;
  activeInput: "token0" | "token1" | null;
}

export function usePosition(params: UsePositionParams) {
  const {
    chainId,
    token0,
    token1,
    fee,
    tickSpacing,
    hooks,
    sqrtPriceX96,
    liquidity,
    tick,
    tickLower,
    tickUpper,
    amount0,
    amount1,
    activeInput,
  } = params;

  return useMemo(() => {
    try {
      // Create SDK Token instances
      const currency0 = new Token(chainId, token0.address, token0.decimals);
      const currency1 = new Token(chainId, token1.address, token1.decimals);

      // Create Pool instance
      const pool = new Pool(
        currency0,
        currency1,
        fee,
        tickSpacing,
        hooks,
        sqrtPriceX96,
        liquidity,
        tick
      );

      // Create Position based on which input is active
      let position: Position;

      if (activeInput === "token0" && amount0) {
        const parsedAmount = BigInt(
          Math.floor(parseFloat(amount0) * 10 ** token0.decimals)
        );
        position = Position.fromAmount0({
          pool,
          tickLower,
          tickUpper,
          amount0: parsedAmount,
          useFullPrecision: true,
        });
      } else if (activeInput === "token1" && amount1) {
        const parsedAmount = BigInt(
          Math.floor(parseFloat(amount1) * 10 ** token1.decimals)
        );
        position = Position.fromAmount1({
          pool,
          tickLower,
          tickUpper,
          amount1: parsedAmount,
        });
      } else {
        return undefined;
      }

      return {
        position,
        pool,
        amount0: position.amount0.quotient,
        amount1: position.amount1.quotient,
        liquidity: position.liquidity,
      };
    } catch (error) {
      console.error("Error creating position:", error);
      return undefined;
    }
  }, [
    chainId,
    token0,
    token1,
    fee,
    tickSpacing,
    hooks,
    sqrtPriceX96,
    liquidity,
    tick,
    tickLower,
    tickUpper,
    amount0,
    amount1,
    activeInput,
  ]);
}
```

---

## Phase 5: Building Features

This phase builds the core UI features: token selection, pool configuration, and forms.

### 5.1 Token Selector Component

```typescript title="src/components/token/TokenSelector.tsx"
import { useState } from "react";
import type { Address } from "viem";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/Dialog";
import { Button } from "@/components/ui/Button";
import { Input } from "@/components/ui/Input";
import { ChevronDown } from "lucide-react";

interface TokenData {
  address: Address;
  symbol: string;
  name: string;
  decimals: number;
  logoURI?: string;
}

interface TokenSelectorProps {
  selectedToken?: TokenData;
  onSelect: (token: TokenData) => void;
  tokens: TokenData[];
}

export function TokenSelector({ selectedToken, onSelect, tokens }: TokenSelectorProps) {
  const [open, setOpen] = useState(false);
  const [search, setSearch] = useState("");

  const filteredTokens = tokens.filter(
    (token) =>
      token.symbol.toLowerCase().includes(search.toLowerCase()) ||
      token.name.toLowerCase().includes(search.toLowerCase())
  );

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button variant="outline" className="gap-2">
          {selectedToken ? (
            <>
              <span>{selectedToken.symbol}</span>
              <ChevronDown className="h-4 w-4" />
            </>
          ) : (
            <>
              Select Token
              <ChevronDown className="h-4 w-4" />
            </>
          )}
        </Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Select a token</DialogTitle>
        </DialogHeader>
        <Input
          placeholder="Search by name or symbol"
          value={search}
          onChange={(e) => setSearch(e.target.value)}
        />
        <div className="max-h-64 overflow-y-auto">
          {filteredTokens.map((token) => (
            <button
              key={token.address}
              className="flex w-full items-center gap-3 p-3 hover:bg-accent rounded-md"
              onClick={() => {
                onSelect(token);
                setOpen(false);
              }}
            >
              {token.logoURI && (
                <img src={token.logoURI} alt={token.symbol} className="h-8 w-8 rounded-full" />
              )}
              <div className="text-left">
                <div className="font-medium">{token.symbol}</div>
                <div className="text-sm text-muted-foreground">{token.name}</div>
              </div>
            </button>
          ))}
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

### 5.2 Token Amount Input

```typescript title="src/components/token/TokenAmountInput.tsx"
import type { Address } from "viem";
import { Input } from "@/components/ui/Input";
import { TokenSelector } from "./TokenSelector";
import { useTokenBalance } from "@/hooks/token/useTokenBalance";
import { formatUnits } from "viem";

interface TokenData {
  address: Address;
  symbol: string;
  name: string;
  decimals: number;
}

interface TokenAmountInputProps {
  token?: TokenData;
  amount: string;
  onAmountChange: (amount: string) => void;
  onTokenSelect: (token: TokenData) => void;
  tokens: TokenData[];
  label?: string;
}

export function TokenAmountInput({
  token,
  amount,
  onAmountChange,
  onTokenSelect,
  tokens,
  label,
}: TokenAmountInputProps) {
  const { balance } = useTokenBalance(token?.address);

  const formattedBalance = balance && token
    ? formatUnits(balance, token.decimals)
    : "0";

  return (
    <div className="rounded-lg border p-4">
      {label && <div className="text-sm text-muted-foreground mb-2">{label}</div>}
      <div className="flex items-center gap-4">
        <Input
          type="text"
          inputMode="decimal"
          placeholder="0.0"
          value={amount}
          onChange={(e) => {
            // Allow only valid decimal input
            const value = e.target.value;
            if (/^[0-9]*\.?[0-9]*$/.test(value)) {
              onAmountChange(value);
            }
          }}
          className="border-0 text-2xl font-medium focus-visible:ring-0"
        />
        <TokenSelector
          selectedToken={token}
          onSelect={onTokenSelect}
          tokens={tokens}
        />
      </div>
      {token && (
        <div className="mt-2 text-sm text-muted-foreground">
          Balance: {parseFloat(formattedBalance).toFixed(6)}
          <button
            className="ml-2 text-primary hover:underline"
            onClick={() => onAmountChange(formattedBalance)}
          >
            MAX
          </button>
        </div>
      )}
    </div>
  );
}
```

### 5.3 Pool Fee Selector

```typescript title="src/components/pool/PoolFeeSelector.tsx"
import { FEE_TIERS } from "@/constants/defaults";
import { cn } from "@/lib/utils";

interface PoolFeeSelectorProps {
  selectedFee: number;
  onSelect: (fee: number, tickSpacing: number) => void;
}

export function PoolFeeSelector({ selectedFee, onSelect }: PoolFeeSelectorProps) {
  return (
    <div className="grid grid-cols-4 gap-2">
      {FEE_TIERS.map((tier) => (
        <button
          key={tier.fee}
          onClick={() => onSelect(tier.fee, tier.tickSpacing)}
          className={cn(
            "rounded-lg border p-3 text-center transition-colors",
            selectedFee === tier.fee
              ? "border-primary bg-primary/10"
              : "hover:border-primary/50"
          )}
        >
          <div className="font-medium">{tier.label}</div>
          <div className="text-xs text-muted-foreground">
            {tier.tickSpacing} tick
          </div>
        </button>
      ))}
    </div>
  );
}
```

### 5.4 Tick Range Selector

```typescript title="src/components/position/TickRangeSelector.tsx"
import { useState } from "react";
import { Input } from "@/components/ui/Input";
import { Label } from "@/components/ui/Label";
import { Switch } from "@/components/ui/Switch";
import { TICK_RANGE_FULL } from "@/constants/defaults";

interface TickRangeSelectorProps {
  tickLower: number;
  tickUpper: number;
  tickSpacing: number;
  onTickLowerChange: (tick: number) => void;
  onTickUpperChange: (tick: number) => void;
}

export function TickRangeSelector({
  tickLower,
  tickUpper,
  tickSpacing,
  onTickLowerChange,
  onTickUpperChange,
}: TickRangeSelectorProps) {
  const [isFullRange, setIsFullRange] = useState(
    tickLower === TICK_RANGE_FULL.tickLower &&
    tickUpper === TICK_RANGE_FULL.tickUpper
  );

  const handleFullRangeToggle = (checked: boolean) => {
    setIsFullRange(checked);
    if (checked) {
      onTickLowerChange(TICK_RANGE_FULL.tickLower);
      onTickUpperChange(TICK_RANGE_FULL.tickUpper);
    }
  };

  const roundToTickSpacing = (tick: number) => {
    return Math.round(tick / tickSpacing) * tickSpacing;
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <Label>Full Range</Label>
        <Switch checked={isFullRange} onCheckedChange={handleFullRangeToggle} />
      </div>

      {!isFullRange && (
        <div className="grid grid-cols-2 gap-4">
          <div>
            <Label>Min Tick</Label>
            <Input
              type="number"
              value={tickLower}
              onChange={(e) => {
                const value = roundToTickSpacing(parseInt(e.target.value) || 0);
                onTickLowerChange(value);
              }}
              step={tickSpacing}
            />
          </div>
          <div>
            <Label>Max Tick</Label>
            <Input
              type="number"
              value={tickUpper}
              onChange={(e) => {
                const value = roundToTickSpacing(parseInt(e.target.value) || 0);
                onTickUpperChange(value);
              }}
              step={tickSpacing}
            />
          </div>
        </div>
      )}
    </div>
  );
}
```

### 5.5 Mint Position Form

Create the main form that ties everything together:

```typescript title="src/components/mint/MintForm.tsx"
import { useState, useCallback, useRef, useEffect } from "react";
import type { Address } from "viem";
import { useAccount, useChainId } from "wagmi";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/Card";
import { Button } from "@/components/ui/Button";
import { TokenAmountInput } from "@/components/token/TokenAmountInput";
import { PoolFeeSelector } from "@/components/pool/PoolFeeSelector";
import { TickRangeSelector } from "@/components/position/TickRangeSelector";
import { ApprovalFlow } from "@/components/approval/ApprovalFlow";
import { usePosition } from "@/hooks/position/usePosition";
import { usePoolState } from "@/hooks/pool/usePoolState";
import { useApprovalFlow } from "@/hooks/approval/useApprovalFlow";
import { useMintPosition } from "@/hooks/transaction/useMintPosition";
import { DEFAULT_POOL, TICK_RANGE_FULL } from "@/constants/defaults";
import { COMMON_TOKENS } from "@/constants/tokens";
import { formatUnits } from "viem";

export function MintForm() {
  const { isConnected } = useAccount();
  const chainId = useChainId();
  const tokens = COMMON_TOKENS[chainId] || [];

  // Form state
  const [token0, setToken0] = useState(tokens[0]);
  const [token1, setToken1] = useState(tokens[1]);
  const [amount0, setAmount0] = useState("");
  const [amount1, setAmount1] = useState("");
  const [fee, setFee] = useState(DEFAULT_POOL.fee);
  const [tickSpacing, setTickSpacing] = useState(DEFAULT_POOL.tickSpacing);
  const [tickLower, setTickLower] = useState(TICK_RANGE_FULL.tickLower);
  const [tickUpper, setTickUpper] = useState(TICK_RANGE_FULL.tickUpper);
  const [activeInput, setActiveInput] = useState<"token0" | "token1" | null>(null);

  // Prevent infinite loops when syncing amounts
  const isCalculatingRef = useRef(false);

  // Pool state from chain
  const { poolState } = usePoolState(
    token0 && token1
      ? {
          currency0: token0.address,
          currency1: token1.address,
          fee,
          tickSpacing,
          hooks: DEFAULT_POOL.hooks,
        }
      : undefined
  );

  // Calculate position from SDK
  const positionData = usePosition({
    chainId,
    token0: token0 ? { address: token0.address, decimals: token0.decimals } : undefined!,
    token1: token1 ? { address: token1.address, decimals: token1.decimals } : undefined!,
    fee,
    tickSpacing,
    hooks: DEFAULT_POOL.hooks,
    sqrtPriceX96: poolState?.sqrtPriceX96 || 0n,
    liquidity: poolState?.liquidity || 0n,
    tick: poolState?.tick || 0,
    tickLower,
    tickUpper,
    amount0,
    amount1,
    activeInput,
  });

  // Sync the other amount when position is calculated
  useEffect(() => {
    if (isCalculatingRef.current || !positionData) return;

    isCalculatingRef.current = true;

    if (activeInput === "token0" && positionData.amount1 !== undefined) {
      const formatted = formatUnits(positionData.amount1, token1?.decimals || 18);
      setAmount1(formatted);
    } else if (activeInput === "token1" && positionData.amount0 !== undefined) {
      const formatted = formatUnits(positionData.amount0, token0?.decimals || 18);
      setAmount0(formatted);
    }

    isCalculatingRef.current = false;
  }, [positionData, activeInput, token0?.decimals, token1?.decimals]);

  // Approval flow
  const { approvalStatus, currentStep, refetchAllowances } = useApprovalFlow({
    token0Address: token0?.address,
    token1Address: token1?.address,
    amount0Max: positionData?.amount0 || 0n,
    amount1Max: positionData?.amount1 || 0n,
  });

  // Mint transaction
  const { mint, isPending, isConfirming, isSuccess, hash } = useMintPosition({
    position: positionData?.position,
    slippageTolerance: 100, // 1%
  });

  const handleAmount0Change = useCallback((value: string) => {
    setActiveInput("token0");
    setAmount0(value);
  }, []);

  const handleAmount1Change = useCallback((value: string) => {
    setActiveInput("token1");
    setAmount1(value);
  }, []);

  const handleFeeSelect = useCallback((newFee: number, newTickSpacing: number) => {
    setFee(newFee);
    setTickSpacing(newTickSpacing);
  }, []);

  const canMint = isConnected && positionData && currentStep === "ready";

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle>Add Liquidity</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <TokenAmountInput
          label="Token 0"
          token={token0}
          amount={amount0}
          onAmountChange={handleAmount0Change}
          onTokenSelect={setToken0}
          tokens={tokens}
        />

        <TokenAmountInput
          label="Token 1"
          token={token1}
          amount={amount1}
          onAmountChange={handleAmount1Change}
          onTokenSelect={setToken1}
          tokens={tokens}
        />

        <div>
          <Label className="mb-2 block">Fee Tier</Label>
          <PoolFeeSelector selectedFee={fee} onSelect={handleFeeSelect} />
        </div>

        <TickRangeSelector
          tickLower={tickLower}
          tickUpper={tickUpper}
          tickSpacing={tickSpacing}
          onTickLowerChange={setTickLower}
          onTickUpperChange={setTickUpper}
        />

        {positionData && (
          <div className="rounded-lg bg-muted p-4 text-sm">
            <div className="flex justify-between">
              <span>Liquidity</span>
              <span>{positionData.liquidity.toString()}</span>
            </div>
          </div>
        )}

        {isConnected && currentStep !== "ready" && (
          <ApprovalFlow
            currentStep={currentStep}
            approvalStatus={approvalStatus}
            onApprovalComplete={refetchAllowances}
          />
        )}

        <Button
          className="w-full"
          disabled={!canMint || isPending || isConfirming}
          onClick={mint}
        >
          {!isConnected
            ? "Connect Wallet"
            : isPending
            ? "Confirming..."
            : isConfirming
            ? "Minting..."
            : isSuccess
            ? "Success!"
            : "Add Liquidity"}
        </Button>

        {hash && (
          <div className="text-sm text-muted-foreground text-center">
            Transaction: {hash.slice(0, 10)}...{hash.slice(-8)}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
```

---

## Phase 6: Advanced Patterns

This phase covers approval flows, transaction management, and production considerations.

### 6.1 Multi-Step Approval Flow

Uniswap V4 uses Permit2 for gas-efficient approvals. The flow requires:

1. **ERC20 Approval to Permit2**: Token → Permit2 contract
2. **Permit2 Approval to PositionManager**: Permit2 → PositionManager

```typescript title="src/hooks/approval/useApprovalFlow.ts"
import { useMemo } from "react";
import type { Address } from "viem";
import { useErc20Allowance } from "./useErc20Allowance";
import { usePermit2Allowance } from "./usePermit2Allowance";
import { useChainId } from "wagmi";
import { getAddress } from "@/constants/addresses";
import type { ApprovalStep } from "@/types/position";
import { MAX_UINT256 } from "@/constants/defaults";

interface UseApprovalFlowParams {
  token0Address?: Address;
  token1Address?: Address;
  amount0Max: bigint;
  amount1Max: bigint;
}

interface ApprovalStatus {
  token0ToPermit2: boolean;
  token1ToPermit2: boolean;
  permit2Token0ToManager: boolean;
  permit2Token1ToManager: boolean;
}

export function useApprovalFlow({
  token0Address,
  token1Address,
  amount0Max,
  amount1Max,
}: UseApprovalFlowParams) {
  const chainId = useChainId();
  const permit2 = getAddress(chainId, "PERMIT2");
  const positionManager = getAddress(chainId, "POSITION_MANAGER");

  // Check ERC20 allowances to Permit2
  const { allowance: erc20Allowance0, refetch: refetchErc20_0 } = useErc20Allowance(
    token0Address,
    permit2
  );
  const { allowance: erc20Allowance1, refetch: refetchErc20_1 } = useErc20Allowance(
    token1Address,
    permit2
  );

  // Check Permit2 allowances to PositionManager
  const { allowance: permit2Allowance0, refetch: refetchPermit2_0 } = usePermit2Allowance(
    token0Address,
    positionManager
  );
  const { allowance: permit2Allowance1, refetch: refetchPermit2_1 } = usePermit2Allowance(
    token1Address,
    positionManager
  );

  // Determine approval status
  const approvalStatus: ApprovalStatus = useMemo(
    () => ({
      token0ToPermit2: (erc20Allowance0 || 0n) >= amount0Max,
      token1ToPermit2: (erc20Allowance1 || 0n) >= amount1Max,
      permit2Token0ToManager: (permit2Allowance0 || 0n) >= amount0Max,
      permit2Token1ToManager: (permit2Allowance1 || 0n) >= amount1Max,
    }),
    [erc20Allowance0, erc20Allowance1, permit2Allowance0, permit2Allowance1, amount0Max, amount1Max]
  );

  // Determine current step
  const currentStep: ApprovalStep = useMemo(() => {
    if (!approvalStatus.token0ToPermit2) return "token0_to_permit2";
    if (!approvalStatus.token1ToPermit2) return "token1_to_permit2";
    if (!approvalStatus.permit2Token0ToManager) return "permit2_token0";
    if (!approvalStatus.permit2Token1ToManager) return "permit2_token1";
    return "ready";
  }, [approvalStatus]);

  const refetchAllowances = () => {
    refetchErc20_0();
    refetchErc20_1();
    refetchPermit2_0();
    refetchPermit2_1();
  };

  return {
    approvalStatus,
    currentStep,
    refetchAllowances,
  };
}
```

### 6.2 Approval Flow UI Component

```typescript title="src/components/approval/ApprovalFlow.tsx"
import type { Address } from "viem";
import { useAccount, useChainId, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import { Button } from "@/components/ui/Button";
import { erc20Abi } from "@/abi/erc20";
import { permit2Abi } from "@/abi/permit2";
import { getAddress } from "@/constants/addresses";
import { MAX_UINT256, MAX_UINT160 } from "@/constants/defaults";
import type { ApprovalStep } from "@/types/position";
import { CheckCircle, Loader2 } from "lucide-react";

interface ApprovalFlowProps {
  currentStep: ApprovalStep;
  token0Address?: Address;
  token1Address?: Address;
  onApprovalComplete: () => void;
}

const STEP_LABELS: Record<ApprovalStep, string> = {
  token0_to_permit2: "Approve Token 0",
  token1_to_permit2: "Approve Token 1",
  permit2_token0: "Permit Token 0",
  permit2_token1: "Permit Token 1",
  ready: "Ready",
};

export function ApprovalFlow({
  currentStep,
  token0Address,
  token1Address,
  onApprovalComplete,
}: ApprovalFlowProps) {
  const chainId = useChainId();
  const permit2 = getAddress(chainId, "PERMIT2");
  const positionManager = getAddress(chainId, "POSITION_MANAGER");

  const { writeContract, data: hash, isPending } = useWriteContract();
  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({ hash });

  // Refetch allowances when transaction succeeds
  if (isSuccess) {
    onApprovalComplete();
  }

  const handleApprove = () => {
    if (currentStep === "token0_to_permit2" && token0Address) {
      writeContract({
        address: token0Address,
        abi: erc20Abi,
        functionName: "approve",
        args: [permit2, MAX_UINT256],
      });
    } else if (currentStep === "token1_to_permit2" && token1Address) {
      writeContract({
        address: token1Address,
        abi: erc20Abi,
        functionName: "approve",
        args: [permit2, MAX_UINT256],
      });
    } else if (currentStep === "permit2_token0" && token0Address) {
      writeContract({
        address: permit2,
        abi: permit2Abi,
        functionName: "approve",
        args: [token0Address, positionManager, MAX_UINT160, Math.floor(Date.now() / 1000) + 86400 * 30],
      });
    } else if (currentStep === "permit2_token1" && token1Address) {
      writeContract({
        address: permit2,
        abi: permit2Abi,
        functionName: "approve",
        args: [token1Address, positionManager, MAX_UINT160, Math.floor(Date.now() / 1000) + 86400 * 30],
      });
    }
  };

  if (currentStep === "ready") {
    return (
      <div className="flex items-center gap-2 text-green-500">
        <CheckCircle className="h-5 w-5" />
        <span>All approvals complete</span>
      </div>
    );
  }

  return (
    <div className="space-y-2">
      <div className="text-sm text-muted-foreground">
        Step: {STEP_LABELS[currentStep]}
      </div>
      <Button
        onClick={handleApprove}
        disabled={isPending || isConfirming}
        className="w-full"
        variant="secondary"
      >
        {isPending || isConfirming ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            {isPending ? "Confirm in wallet..." : "Confirming..."}
          </>
        ) : (
          STEP_LABELS[currentStep]
        )}
      </Button>
    </div>
  );
}
```

### 6.3 Transaction Hook with SDK Integration

```typescript title="src/hooks/transaction/useMintPosition.ts"
import { useCallback } from "react";
import type { Hex } from "viem";
import { useAccount, useChainId, useSendTransaction, useWaitForTransactionReceipt } from "wagmi";
import { V4PositionManager } from "@muniswap/v4-sdk";
import { Percent } from "@muniswap/sdk-core";
import type { Position } from "@muniswap/v4-sdk";
import { getAddress } from "@/constants/addresses";
import { DEFAULT_DEADLINE_MINUTES } from "@/constants/defaults";

interface UseMintPositionParams {
  position?: Position;
  slippageTolerance: number; // In bps (100 = 1%)
}

export function useMintPosition({ position, slippageTolerance }: UseMintPositionParams) {
  const { address: recipient } = useAccount();
  const chainId = useChainId();
  const positionManager = getAddress(chainId, "POSITION_MANAGER");

  const {
    sendTransaction,
    data: hash,
    isPending,
    error: sendError,
  } = useSendTransaction();

  const {
    isLoading: isConfirming,
    isSuccess,
    error: confirmError,
  } = useWaitForTransactionReceipt({ hash });

  const mint = useCallback(() => {
    if (!position || !recipient) return;

    // Calculate deadline (current time + minutes)
    const deadline = BigInt(Math.floor(Date.now() / 1000) + DEFAULT_DEADLINE_MINUTES * 60);

    // Generate calldata using SDK
    const { calldata, value } = V4PositionManager.addCallParameters(position, {
      slippageTolerance: new Percent(slippageTolerance, 10000),
      deadline,
      recipient,
    });

    // Send transaction
    sendTransaction({
      to: positionManager,
      data: calldata as Hex,
      value: BigInt(value),
    });
  }, [position, recipient, slippageTolerance, positionManager, sendTransaction]);

  return {
    mint,
    hash,
    isPending,
    isConfirming,
    isSuccess,
    error: sendError || confirmError,
  };
}
```

### 6.4 Formatting Utilities

```typescript title="src/lib/format.ts"
import { formatUnits, parseUnits } from "viem";

export function shortenAddress(address: string, chars = 4): string {
  return `${address.slice(0, chars + 2)}...${address.slice(-chars)}`;
}

export function formatTokenAmount(
  amount: bigint,
  decimals: number,
  displayDecimals = 6
): string {
  const formatted = formatUnits(amount, decimals);
  const num = parseFloat(formatted);

  if (num === 0) return "0";
  if (num < 0.000001) return "<0.000001";

  return num.toLocaleString(undefined, {
    minimumFractionDigits: 0,
    maximumFractionDigits: displayDecimals,
  });
}

export function parseTokenAmount(amount: string, decimals: number): bigint {
  if (!amount || amount === "") return 0n;
  try {
    return parseUnits(amount, decimals);
  } catch {
    return 0n;
  }
}

export function sqrtPriceX96ToPrice(
  sqrtPriceX96: bigint,
  decimals0: number,
  decimals1: number
): number {
  const Q96 = 2n ** 96n;
  const price = (sqrtPriceX96 * sqrtPriceX96) / Q96;
  const adjustedPrice = Number(price) / Number(Q96);
  const decimalAdjustment = 10 ** (decimals0 - decimals1);
  return adjustedPrice * decimalAdjustment;
}

export function tickToPrice(
  tick: number,
  decimals0: number,
  decimals1: number
): number {
  const price = 1.0001 ** tick;
  const decimalAdjustment = 10 ** (decimals0 - decimals1);
  return price * decimalAdjustment;
}
```

### 6.5 App Entry Point and Routing

```typescript title="src/App.tsx"
import { createRouter, createRootRoute, createRoute, RouterProvider, Outlet, Link } from "@tanstack/react-router";
import { Providers } from "@/providers";
import { Header } from "@/components/layout/Header";
import { MintPage } from "@/pages/MintPage";
import { SwapPage } from "@/pages/SwapPage";

// Root layout
const rootRoute = createRootRoute({
  component: () => (
    <div className="dark min-h-screen bg-background text-foreground">
      <Header />
      <main className="container py-8">
        <Outlet />
      </main>
    </div>
  ),
});

// Routes
const indexRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "/",
  component: () => (
    <div className="text-center py-12">
      <h1 className="text-4xl font-bold mb-4">Uniswap V4</h1>
      <p className="text-muted-foreground mb-8">Manage liquidity and swap tokens</p>
      <div className="flex gap-4 justify-center">
        <Link to="/mint" className="text-primary hover:underline">Add Liquidity</Link>
        <Link to="/swap" className="text-primary hover:underline">Swap</Link>
      </div>
    </div>
  ),
});

const mintRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "/mint",
  component: MintPage,
});

const swapRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "/swap",
  component: SwapPage,
});

// Router
const routeTree = rootRoute.addChildren([indexRoute, mintRoute, swapRoute]);
const router = createRouter({ routeTree });

// Type registration
declare module "@tanstack/react-router" {
  interface Register {
    router: typeof router;
  }
}

export default function App() {
  return (
    <Providers>
      <RouterProvider router={router} />
    </Providers>
  );
}
```

```typescript title="src/main.tsx"
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

---

## Summary

### Phase Overview

| Phase | Focus | Key Technologies |
|-------|-------|------------------|
| 1 | Project Setup | Vite, TypeScript, Biome |
| 2 | UI Foundation | Tailwind CSS, shadcn/ui, Radix UI |
| 3 | Web3 Integration | wagmi, viem, RainbowKit |
| 4 | SDK Integration | @muniswap/sdk-core, @muniswap/v4-sdk |
| 5 | Building Features | Token selection, Pool config, Forms |
| 6 | Advanced Patterns | Permit2 approvals, Transaction management |

### Key Patterns Used

1. **Memoization**: Use `useMemo` for SDK calculations to prevent recreation
2. **Conditional Execution**: Use `query.enabled` in wagmi hooks
3. **Ref Tracking**: Use `useRef` to prevent infinite update loops
4. **Multi-step State**: Track approval flow with enum states
5. **Type Safety**: Leverage viem's `Address` type throughout

### Production Considerations

- Add error boundaries for graceful failure handling
- Implement retry logic for failed transactions
- Add loading skeletons for better UX
- Consider caching strategies for token lists
- Add analytics and error tracking
- Test across multiple chains and wallets

### Next Steps

- Explore the reference implementation in `apps/ui/`
- Review the SDK documentation for advanced features
- Add swap functionality following similar patterns
- Implement position viewing and management
